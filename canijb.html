<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rage‚Äôs JB Checker</title>
    <link rel="stylesheet" href="irk.css">
</head>
<body>

    <div class="search-container">
        <span class="search-icon" onclick="toggleSearch()">üîç</span>
        <div class="search-box">
            <input type="text" class="search-input" placeholder="Search device..." oninput="searchDevices()">
            <div class="search-results"></div>
        </div>
    </div>

    <h1>Rage‚Äôs JB Checker</h1>
    <div id="content"></div>
    <p class="text-center">
        Source: <a href="https://github.com/littlebyteorg/appledb" target="_blank">littlebyteorg/appledb</a>
    </p>

    <script>
        const apiBase = "https://api.github.com/repos/littlebyteorg/appledb/contents/jailbreakFiles";
        const rawBase = "https://raw.githubusercontent.com/littlebyteorg/appledb/main/jailbreakFiles/";
        const devCache = new Map();
        const jbData = [];

        async function getDevInfo(id) {
            if (devCache.has(id)) return devCache.get(id);
            const url = `https://api.ipsw.me/v4/device/${id}?type=ipsw`;
            let info = { name: id, vers: new Map() };

            try {
                let res = await fetch(url);
                if (!res.ok) throw new Error();
                let d = await res.json();
                info.name = d.name || id;
                d.firmwares?.forEach(f => info.vers.set(f.buildid, f.version));
                devCache.set(id, info);
            } catch (e) {}

            return info;
        }

        async function fetchJBs() {
            try {
                let res = await fetch(apiBase);
                let data = await res.json();
                data.filter(f => f.name.endsWith(".json")).forEach(f => fetchJBFile(f.name));
            } catch (e) {}
        }

        async function fetchJBFile(file) {
            try {
                let res = await fetch(rawBase + file);
                let data = await res.json();
                processJB(data, file);
            } catch (e) {}
        }

        async function processJB(data, file) {
            const card = document.createElement("div");
            card.className = "card";

            const title = document.createElement("h2");
            title.className = "title";
            title.textContent = data.info?.name?.trim() || file.replace(".json", "");

            const latest = mk("Latest Version", data.info?.latestVer);
            const type = mk("Type", data.info?.type);
            const notes = mk("Notes", data.info?.notes);

            const sel = document.createElement("select");
            sel.innerHTML = `<option value="">Select a device</option>`;

            const listWrap = document.createElement("div");
            listWrap.className = "list";
            const list = document.createElement("ul");

            let devMap = {};

            for (const e of data.compatibility) {
                for (const v of e.devices) {
                    if (!devMap[v]) devMap[v] = new Set();
                    e.firmwares.forEach(fw => devMap[v].add(fw));
                }
            }

            const uniqueDevs = Object.keys(devMap);
            const devs = await Promise.all(uniqueDevs.map(getDevInfo));

            uniqueDevs.forEach((v, i) => {
                let opt = document.createElement("option");
                opt.value = v;
                opt.textContent = devs[i].name;
                sel.appendChild(opt);

                jbData.push({ id: v, name: devs[i].name, jb: title.textContent, element: card });
            });

            sel.addEventListener("change", function () {
                let v = this.value;
                list.innerHTML = "";
                if (v) {
                    let knownVers = [], unknownVers = [];
                    devMap[v].forEach(fw => {
                        let devInfo = devCache.get(v);
                        let ios = devInfo?.vers?.get(fw);
                        if (ios) knownVers.push(ios);
                        else unknownVers.push(fw);
                    });

                    knownVers.sort().forEach(ios => appendListItem(list, ios));
                    unknownVers.sort().forEach(fw => appendListItem(list, fw));

                    listWrap.style.display = "block";
                } else {
                    listWrap.style.display = "none";
                }
            });

            listWrap.appendChild(list);
            card.append(title, latest, type, notes, sel, listWrap);
            document.getElementById("content").appendChild(card);
        }

        function mk(k, v) {
            const p = document.createElement("p");
            p.className = "info";
            p.innerHTML = `<strong>${k}:</strong> ${v || "N/A"}`;
            return p;
        }

        function appendListItem(list, text) {
            let li = document.createElement("li");
            li.textContent = text;
            list.appendChild(li);
        }

        function toggleSearch() {
            document.querySelector(".search-box").style.display ^= "block";
        }

        function searchDevices() {
            const query = document.querySelector(".search-input").value.toLowerCase();
            const resultsContainer = document.querySelector(".search-results");
            resultsContainer.innerHTML = "";

            if (!query) return;

            let results = jbData.filter(d => d.name.toLowerCase().includes(query));

            results.forEach(d => {
                let link = document.createElement("a");
                link.href = "#";
                link.textContent = `${d.name} - ${d.jb}`;
                link.onclick = () => {
                    d.element.scrollIntoView({ behavior: "smooth" });
                    toggleSearch();
                };
                resultsContainer.appendChild(link);
            });
        }

        fetchJBs();
    </script>

</body>
</html>
