<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rage‚Äôs JB Checker</title>
    <link rel="stylesheet" href="irk.css">
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>

    <div class="container">
        <div class="search-container">
            <span id="searchIcon" class="search-icon">üîç</span>
        </div>

        <h1>Rage‚Äôs JB Checker</h1>
        <div id="j"></div>

        <div class="text-center mt-5">
            Source: <a href="https://github.com/littlebyteorg/appledb" target="_blank" class="text-blue-400">littlebyteorg/appledb</a>
        </div>
    </div>

    <div id="searchBox" class="search-box">
        <input type="text" id="searchInput" placeholder="Search for your device..." autocomplete="off">
    </div>

    <div id="searchResults" class="search-results hidden"></div>

    <script>
        const apiBase = "https://api.github.com/repos/littlebyteorg/appledb/contents/jailbreakFiles";
        const rawBase = "https://raw.githubusercontent.com/littlebyteorg/appledb/main/jailbreakFiles/";
        const ipswAPI = "https://api.ipsw.me/v4";

        let deviceMap = {};
        let firmwareMap = {};

        async function fetchMappings() {
            try {
                const [devicesRes, firmwareRes] = await Promise.all([
                    fetch(`${ipswAPI}/devices`),
                    fetch(`${ipswAPI}/firmwares`)
                ]);

                const devicesData = await devicesRes.json();
                const firmwareData = await firmwareRes.json();

                devicesData.forEach(d => {
                    deviceMap[d.identifier] = d.name;
                });

                firmwareData.forEach(f => {
                    firmwareMap[f.buildid] = f.version + ` (${f.buildid})`;
                });

                localStorage.setItem("deviceMap", JSON.stringify(deviceMap));
                localStorage.setItem("firmwareMap", JSON.stringify(firmwareMap));
            } catch (e) {
                console.error("Error fetching IPSW API data:", e);
            }
        }

        function loadCachedMappings() {
            const cachedDevices = localStorage.getItem("deviceMap");
            const cachedFirmwares = localStorage.getItem("firmwareMap");

            if (cachedDevices && cachedFirmwares) {
                deviceMap = JSON.parse(cachedDevices);
                firmwareMap = JSON.parse(cachedFirmwares);
            } else {
                fetchMappings();
            }
        }

        async function fetchJailbreaks() {
            try {
                const res = await fetch(apiBase);
                const data = await res.json();
                data.filter(x => x.name.endsWith(".json")).forEach(x => fetchJBData(x.name));
            } catch (e) {
                console.error("Error fetching jailbreak files:", e);
            }
        }

        async function fetchJBData(name) {
            try {
                const res = await fetch(rawBase + name);
                const data = await res.json();
                displayJB(data, name);
            } catch (e) {
                console.error(`Error fetching ${name}:`, e);
            }
        }

        function displayJB(data, name) {
            const container = document.createElement("div");
            container.className = "card";

            const title = document.createElement("h2");
            title.textContent = data.info?.name?.trim() || name.replace(".json", "");

            const latestVer = createInfo("Latest Version", data.info?.latestVer);
            const type = createInfo("Type", data.info?.type);
            const notes = createInfo("Notes", data.info?.notes);

            const select = document.createElement("select");
            select.className = "select";
            select.innerHTML = `<option value="">Select a device</option>`;

            const listContainer = document.createElement("div");
            listContainer.className = "list hidden";

            const list = document.createElement("ul");
            let compatibilityMap = {};

            data.compatibility.forEach(entry => {
                entry.devices.forEach(device => {
                    let readableDevice = deviceMap[device] || device;
                    if (!compatibilityMap[readableDevice]) compatibilityMap[readableDevice] = new Set();

                    entry.firmwares.forEach(fw => {
                        let readableFW = firmwareMap[fw] || fw;
                        compatibilityMap[readableDevice].add(readableFW);
                    });
                });
            });

            Object.keys(compatibilityMap).sort().forEach(device => {
                let option = document.createElement("option");
                option.value = device;
                option.textContent = device;
                select.appendChild(option);
            });

            select.addEventListener("change", function () {
                const val = this.value;
                if (val) {
                    list.innerHTML = "";
                    compatibilityMap[val].forEach(fw => {
                        let item = document.createElement("li");
                        item.textContent = fw;
                        list.appendChild(item);
                    });
                    listContainer.classList.remove("hidden");
                } else {
                    listContainer.classList.add("hidden");
                }
            });

            listContainer.appendChild(list);
            container.append(title, latestVer, type, notes, select, listContainer);
            document.getElementById("j").appendChild(container);
        }

        function createInfo(label, value) {
            const p = document.createElement("p");
            p.innerHTML = `<strong>${label}:</strong> ${value || "N/A"}`;
            return p;
        }

        loadCachedMappings();
        fetchJailbreaks();

        // Search functionality
        document.getElementById("searchIcon").addEventListener("click", () => {
            document.getElementById("searchBox").classList.toggle("hidden");
            document.getElementById("searchInput").focus();
        });

        document.getElementById("searchInput").addEventListener("input", function () {
            const query = this.value.toLowerCase();
            const resultsDiv = document.getElementById("searchResults");
            resultsDiv.innerHTML = "";

            if (!query) {
                resultsDiv.classList.add("hidden");
                return;
            }

            const items = document.querySelectorAll(".card h2");
            let results = [];

            items.forEach(item => {
                if (item.textContent.toLowerCase().includes(query)) {
                    results.push(`<div class="result-item">${item.textContent}</div>`);
                }
            });

            if (results.length) {
                resultsDiv.classList.remove("hidden");
                resultsDiv.innerHTML = results.join("");
            } else {
                resultsDiv.classList.add("hidden");
            }
        });

        document.getElementById("searchResults").addEventListener("click", function (e) {
            if (e.target.classList.contains("result-item")) {
                let selectedText = e.target.textContent;
                let allCards = document.querySelectorAll(".card h2");

                allCards.forEach(card => {
                    if (card.textContent === selectedText) {
                        card.scrollIntoView({ behavior: "smooth" });
                        document.getElementById("searchBox").classList.add("hidden");
                        document.getElementById("searchResults").classList.add("hidden");
                        document.getElementById("searchInput").value = "";
                    }
                });
            }
        });

    </script>
</body>
</html>
